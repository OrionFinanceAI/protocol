/**
 * OrchestratorPerformUpkeep.test.ts
 *
 * This file contains the core orchestrator performUpkeep functionality tests.
 * It was extracted from the original Orchestrators.test.ts file (lines 1-2464).
 *
 * WHAT THIS FILE TESTS:
 * ======================
 *
 * 1. IDLE-ONLY FUNCTIONALITY (1 test)
 *    - Tests that actions requiring Idle state can only be executed when both
 *      InternalStatesOrchestrator (ISO) and LiquidityOrchestrator (LO) are in Idle phase (0)
 *    - Verifies submitIntent, requestDeposit, and requestRedeem revert when system is not idle
 *
 * 2. PERFORMUPKEEP FUNCTIONALITY (18 tests)
 *    Tests the complete orchestration cycle including:
 *
 *    a) InternalStatesOrchestrator (ISO) Phases:
 *       - Idle (0) → Preprocessing (1) → Buffering (2) → Postprocessing (3) → BuildingOrders (4) → Idle (0)
 *       - ISO processes vaults in minibatches to update internal states
 *       - Tests cover:
 *         * Full epoch processing with multiple vaults
 *         * Vault state calculations (NAV, performance fees, management fees)
 *         * Fee collection and distribution
 *         * High water mark tracking
 *         * Hurdle rate applications (soft/hard/with HWM)
 *         * Minibatch processing across phases
 *
 *    b) LiquidityOrchestrator (LO) Phases:
 *       - Idle (0) → SellingLeg (1) → BuyingLeg (2) → FulfillDepositAndRedeem (3) → Idle (0)
 *       - LO executes rebalancing orders generated by ISO
 *       - Tests cover:
 *         * Order generation from vault intents
 *         * Selling leg execution (redeeming from assets)
 *         * Buying leg execution (depositing into assets)
 *         * Deposit/redeem fulfillment for users
 *         * Buffer management and target buffer ratios
 *         * Minibatch processing across phases
 *
 *    c) Fee Model Tests (6 different vault types):
 *       - Absolute Fee Vault: Performance fee charged on all positive returns
 *       - Soft Hurdle Vault: Performance fee only on returns above hurdle rate
 *       - Hard Hurdle Vault: Performance fee only charged on excess above hurdle
 *       - High Water Mark Vault: Performance fee only on gains above previous peak
 *       - Hurdle+HWM Vault: Combined hurdle rate and high water mark logic
 *       - Passive Vault: No fees, uses KBestTvlWeightedAverage strategy
 *
 *    d) Integration Tests:
 *       - Full epoch cycles (ISO → LO → ISO → LO...)
 *       - Multiple vaults with different fee structures
 *       - User deposit/redeem request handling
 *       - Share pricing and NAV calculations
 *       - Protocol fee collection
 *
 * STRUCTURE:
 * ==========
 * - Lines 1-578: beforeEach setup block (deployed contracts, vaults, initial deposits)
 * - Lines 579-689: Idle-only functionality test (1 test)
 * - Lines 690-2464: performUpkeep tests (18 tests)
 *
 * TEST PATTERNS:
 * ==============
 * - Uses beforeEach (not loadFixture) to deploy fresh contracts for each test
 * - Manual epoch processing with while loops (not helper functions)
 * - Advances time between epochs to allow rebalancing
 * - Checks phase transitions, state updates, and fee calculations
 *
 * TOTAL TESTS: 19
 */

import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { expect } from "chai";
import { ethers } from "hardhat";
import { time } from "@nomicfoundation/hardhat-network-helpers";

import {
  MockUnderlyingAsset,
  MockERC4626Asset,
  OrionAssetERC4626ExecutionAdapter,
  OrionConfig,
  InternalStatesOrchestrator,
  LiquidityOrchestrator,
  TransparentVaultFactory,
  OrionTransparentVault,
  PriceAdapterRegistry,
  OrionAssetERC4626PriceAdapter,
  KBestTvlWeightedAverage,
} from "../../typechain-types";

describe("Orchestrator PerformUpkeep", function () {
  // Vault deposit amounts (in underlying asset units)
  const ABSOLUTE_VAULT_DEPOSIT = 50;
  const SOFT_HURDLE_VAULT_DEPOSIT = 125;
  const HARD_HURDLE_VAULT_DEPOSIT = 200;
  const HIGH_WATER_MARK_VAULT_DEPOSIT = 75;
  const HURDLE_HWM_VAULT_DEPOSIT = 150;
  const PASSIVE_VAULT_DEPOSIT = 100;

  // Expected price factors for mock assets after gains/losses (logged)
  const MOCK_ASSET1_P0 = 1.55;
  const MOCK_ASSET2_P0 = 1.5;
  const MOCK_ASSET3_P0 = 1.055;

  let transparentVaultFactory: TransparentVaultFactory;
  let orionConfig: OrionConfig;
  let underlyingAsset: MockUnderlyingAsset;
  let mockAsset1: MockERC4626Asset;
  let mockAsset2: MockERC4626Asset;
  let mockAsset3: MockERC4626Asset;
  let orionPriceAdapter: OrionAssetERC4626PriceAdapter;
  let orionExecutionAdapter: OrionAssetERC4626ExecutionAdapter;
  let priceAdapterRegistry: PriceAdapterRegistry;
  let internalStatesOrchestrator: InternalStatesOrchestrator;
  let liquidityOrchestrator: LiquidityOrchestrator;
  let absoluteVault: OrionTransparentVault;
  let highWaterMarkVault: OrionTransparentVault;
  let softHurdleVault: OrionTransparentVault;
  let hardHurdleVault: OrionTransparentVault;
  let hurdleHwmVault: OrionTransparentVault;
  let kbestTvlStrategy: KBestTvlWeightedAverage;
  let passiveVault: OrionTransparentVault;

  let underlyingDecimals: number;

  let owner: SignerWithAddress;
  let curator: SignerWithAddress;
  let automationRegistry: SignerWithAddress;
  let user: SignerWithAddress;

  beforeEach(async function () {
    [owner, curator, automationRegistry, user] = await ethers.getSigners();

    underlyingDecimals = 12;

    const MockUnderlyingAssetFactory = await ethers.getContractFactory("MockUnderlyingAsset");
    const underlyingAssetDeployed = await MockUnderlyingAssetFactory.deploy(underlyingDecimals);
    await underlyingAssetDeployed.waitForDeployment();
    underlyingAsset = underlyingAssetDeployed as unknown as MockUnderlyingAsset;

    const MockERC4626AssetFactory = await ethers.getContractFactory("MockERC4626Asset");
    const mockAsset1Deployed = await MockERC4626AssetFactory.deploy(
      await underlyingAsset.getAddress(),
      "Mock Asset 1",
      "MA1",
    );
    await mockAsset1Deployed.waitForDeployment();
    mockAsset1 = mockAsset1Deployed as unknown as MockERC4626Asset;

    const mockAsset2Deployed = await MockERC4626AssetFactory.deploy(
      await underlyingAsset.getAddress(),
      "Mock Asset 2",
      "MA2",
    );
    await mockAsset2Deployed.waitForDeployment();
    mockAsset2 = mockAsset2Deployed as unknown as MockERC4626Asset;

    const mockAsset3Deployed = await MockERC4626AssetFactory.deploy(
      await underlyingAsset.getAddress(),
      "Mock Asset 3",
      "MA3",
    );
    await mockAsset3Deployed.waitForDeployment();
    mockAsset3 = mockAsset3Deployed as unknown as MockERC4626Asset;

    // Deposit in investment universe vault to be able to simulate losses.
    await underlyingAsset.mint(user.address, ethers.parseUnits("50000", underlyingDecimals));

    const initialDeposit = ethers.parseUnits("1000", underlyingDecimals);

    await underlyingAsset.connect(user).approve(await mockAsset1.getAddress(), initialDeposit);
    await mockAsset1.connect(user).deposit(initialDeposit, user.address);

    await underlyingAsset.connect(user).approve(await mockAsset2.getAddress(), initialDeposit);
    await mockAsset2.connect(user).deposit(initialDeposit, user.address);

    await underlyingAsset.connect(user).approve(await mockAsset3.getAddress(), initialDeposit * BigInt(2));
    await mockAsset3.connect(user).deposit(initialDeposit * BigInt(2), user.address);

    await underlyingAsset
      .connect(user)
      .approve(await mockAsset1.getAddress(), ethers.parseUnits("50", underlyingDecimals));
    await underlyingAsset
      .connect(user)
      .approve(await mockAsset2.getAddress(), ethers.parseUnits("30", underlyingDecimals));
    await underlyingAsset
      .connect(user)
      .approve(await mockAsset3.getAddress(), ethers.parseUnits("60", underlyingDecimals));

    await mockAsset1.connect(user).simulateGains(ethers.parseUnits("50", underlyingDecimals));
    await mockAsset2.connect(user).simulateLosses(ethers.parseUnits("30", underlyingDecimals), user.address);
    await mockAsset3.connect(user).simulateGains(ethers.parseUnits("60", underlyingDecimals));

    const decimals1 = await mockAsset1.decimals();
    const decimals2 = await mockAsset2.decimals();
    const decimals3 = await mockAsset3.decimals();
    const currentSharePrice1 = await mockAsset1.convertToAssets(10n ** BigInt(decimals1));
    const currentSharePrice2 = await mockAsset2.convertToAssets(10n ** BigInt(decimals2));
    const currentSharePrice3 = await mockAsset3.convertToAssets(10n ** BigInt(decimals3));

    console.log(currentSharePrice1);
    console.log(currentSharePrice2);
    console.log(currentSharePrice3);

    const OrionConfigFactory = await ethers.getContractFactory("OrionConfig");
    const orionConfigDeployed = await OrionConfigFactory.deploy(
      owner.address,
      user.address, // admin
      await underlyingAsset.getAddress(),
    );
    await orionConfigDeployed.waitForDeployment();
    orionConfig = orionConfigDeployed as unknown as OrionConfig;

    // Deploy KBestTvlWeightedAverage strategy with k=2
    const KBestTvlWeightedAverageFactory = await ethers.getContractFactory("KBestTvlWeightedAverage");
    const kbestTvlStrategyDeployed = await KBestTvlWeightedAverageFactory.deploy(
      owner.address,
      await orionConfig.getAddress(),
      1, // k=1
    );
    await kbestTvlStrategyDeployed.waitForDeployment();
    kbestTvlStrategy = kbestTvlStrategyDeployed as unknown as KBestTvlWeightedAverage;

    const PriceAdapterRegistryFactory = await ethers.getContractFactory("PriceAdapterRegistry");
    const priceAdapterRegistryDeployed = await PriceAdapterRegistryFactory.deploy(
      owner.address,
      await orionConfig.getAddress(),
    );
    await priceAdapterRegistryDeployed.waitForDeployment();
    priceAdapterRegistry = priceAdapterRegistryDeployed as unknown as PriceAdapterRegistry;

    const OrionAssetERC4626PriceAdapterFactory = await ethers.getContractFactory("OrionAssetERC4626PriceAdapter");
    orionPriceAdapter = (await OrionAssetERC4626PriceAdapterFactory.deploy(
      await orionConfig.getAddress(),
    )) as unknown as OrionAssetERC4626PriceAdapter;
    await orionPriceAdapter.waitForDeployment();

    const TransparentVaultFactoryFactory = await ethers.getContractFactory("TransparentVaultFactory");
    const transparentVaultFactoryDeployed = await TransparentVaultFactoryFactory.deploy(await orionConfig.getAddress());
    await transparentVaultFactoryDeployed.waitForDeployment();
    transparentVaultFactory = transparentVaultFactoryDeployed as unknown as TransparentVaultFactory;

    const LiquidityOrchestratorFactory = await ethers.getContractFactory("LiquidityOrchestrator");
    const liquidityOrchestratorDeployed = await LiquidityOrchestratorFactory.deploy(
      owner.address,
      await orionConfig.getAddress(),
      automationRegistry.address,
    );
    await liquidityOrchestratorDeployed.waitForDeployment();
    liquidityOrchestrator = liquidityOrchestratorDeployed as unknown as LiquidityOrchestrator;

    await orionConfig.setLiquidityOrchestrator(await liquidityOrchestrator.getAddress());
    await orionConfig.setPriceAdapterRegistry(await priceAdapterRegistry.getAddress());

    const InternalStatesOrchestratorFactory = await ethers.getContractFactory("InternalStatesOrchestrator");
    const internalStatesOrchestratorDeployed = await InternalStatesOrchestratorFactory.deploy(
      owner.address,
      await orionConfig.getAddress(),
      automationRegistry.address,
    );
    await internalStatesOrchestratorDeployed.waitForDeployment();
    internalStatesOrchestrator = internalStatesOrchestratorDeployed as unknown as InternalStatesOrchestrator;

    await orionConfig.setInternalStatesOrchestrator(await internalStatesOrchestrator.getAddress());
    await orionConfig.setVaultFactory(await transparentVaultFactory.getAddress());

    await internalStatesOrchestrator.connect(owner).updateProtocolFees(10, 1000);

    await expect(internalStatesOrchestrator.connect(owner).updateProtocolFees(51, 0)).to.be.revertedWithCustomError(
      internalStatesOrchestrator,
      "InvalidArguments",
    );

    await expect(internalStatesOrchestrator.connect(owner).updateProtocolFees(0, 2001)).to.be.revertedWithCustomError(
      internalStatesOrchestrator,
      "InvalidArguments",
    );

    await liquidityOrchestrator.setInternalStatesOrchestrator(await internalStatesOrchestrator.getAddress());

    await expect(liquidityOrchestrator.setTargetBufferRatio(0)).to.be.revertedWithCustomError(
      liquidityOrchestrator,
      "InvalidArguments",
    );

    await expect(liquidityOrchestrator.setTargetBufferRatio(501)).to.be.revertedWithCustomError(
      liquidityOrchestrator,
      "InvalidArguments",
    );

    await expect(liquidityOrchestrator.setTargetBufferRatio(100)).to.not.be.reverted;

    // Set minibatch size to a large value to process all vaults in one batch for tests
    await liquidityOrchestrator.connect(owner).updateMinibatchSize(8);

    const OrionAssetERC4626ExecutionAdapterFactory = await ethers.getContractFactory(
      "OrionAssetERC4626ExecutionAdapter",
    );
    orionExecutionAdapter = (await OrionAssetERC4626ExecutionAdapterFactory.deploy(
      await orionConfig.getAddress(),
    )) as unknown as OrionAssetERC4626ExecutionAdapter;
    await orionExecutionAdapter.waitForDeployment();

    await orionConfig.addWhitelistedAsset(
      await mockAsset1.getAddress(),
      await orionPriceAdapter.getAddress(),
      await orionExecutionAdapter.getAddress(),
    );
    await orionConfig.addWhitelistedAsset(
      await mockAsset2.getAddress(),
      await orionPriceAdapter.getAddress(),
      await orionExecutionAdapter.getAddress(),
    );
    await orionConfig.addWhitelistedAsset(
      await mockAsset3.getAddress(),
      await orionPriceAdapter.getAddress(),
      await orionExecutionAdapter.getAddress(),
    );

    await orionConfig.setProtocolRiskFreeRate(0.0423 * 10_000);

    await orionConfig.addWhitelistedCurator(curator.address);

    const absoluteVaultTx = await transparentVaultFactory
      .connect(owner)
      .createVault(curator.address, "Absolute Fee Vault", "AFV", 0, 500, 50);
    const absoluteVaultReceipt = await absoluteVaultTx.wait();
    const absoluteVaultEvent = absoluteVaultReceipt?.logs.find((log) => {
      try {
        const parsed = transparentVaultFactory.interface.parseLog(log);
        return parsed?.name === "OrionVaultCreated";
      } catch {
        return false;
      }
    });
    const absoluteVaultParsedEvent = transparentVaultFactory.interface.parseLog(absoluteVaultEvent!);
    const absoluteVaultAddress = absoluteVaultParsedEvent?.args[0];
    absoluteVault = (await ethers.getContractAt(
      "OrionTransparentVault",
      absoluteVaultAddress,
    )) as unknown as OrionTransparentVault;

    const softHurdleVaultTx = await transparentVaultFactory
      .connect(owner)
      .createVault(curator.address, "Soft Hurdle Vault", "SHV", 1, 1200, 80);
    const softHurdleVaultReceipt = await softHurdleVaultTx.wait();
    const softHurdleVaultEvent = softHurdleVaultReceipt?.logs.find((log) => {
      try {
        const parsed = transparentVaultFactory.interface.parseLog(log);
        return parsed?.name === "OrionVaultCreated";
      } catch {
        return false;
      }
    });
    const softHurdleVaultParsedEvent = transparentVaultFactory.interface.parseLog(softHurdleVaultEvent!);
    const softHurdleVaultAddress = softHurdleVaultParsedEvent?.args[0];
    softHurdleVault = (await ethers.getContractAt(
      "OrionTransparentVault",
      softHurdleVaultAddress,
    )) as unknown as OrionTransparentVault;

    const hardHurdleVaultTx = await transparentVaultFactory
      .connect(owner)
      .createVault(curator.address, "Hard Hurdle Vault", "HHV", 2, 1500, 200);
    const hardHurdleVaultReceipt = await hardHurdleVaultTx.wait();
    const hardHurdleVaultEvent = hardHurdleVaultReceipt?.logs.find((log) => {
      try {
        const parsed = transparentVaultFactory.interface.parseLog(log);
        return parsed?.name === "OrionVaultCreated";
      } catch {
        return false;
      }
    });
    const hardHurdleVaultParsedEvent = transparentVaultFactory.interface.parseLog(hardHurdleVaultEvent!);
    const hardHurdleVaultAddress = hardHurdleVaultParsedEvent?.args[0];
    hardHurdleVault = (await ethers.getContractAt(
      "OrionTransparentVault",
      hardHurdleVaultAddress,
    )) as unknown as OrionTransparentVault;

    const highWaterMarkVaultTx = await transparentVaultFactory
      .connect(owner)
      .createVault(curator.address, "High Water Mark Vault", "HWMV", 3, 800, 150);
    const highWaterMarkVaultReceipt = await highWaterMarkVaultTx.wait();
    const highWaterMarkVaultEvent = highWaterMarkVaultReceipt?.logs.find((log) => {
      try {
        const parsed = transparentVaultFactory.interface.parseLog(log);
        return parsed?.name === "OrionVaultCreated";
      } catch {
        return false;
      }
    });
    const highWaterMarkVaultParsedEvent = transparentVaultFactory.interface.parseLog(highWaterMarkVaultEvent!);
    const highWaterMarkVaultAddress = highWaterMarkVaultParsedEvent?.args[0];
    highWaterMarkVault = (await ethers.getContractAt(
      "OrionTransparentVault",
      highWaterMarkVaultAddress,
    )) as unknown as OrionTransparentVault;

    const hurdleHwmVaultTx = await transparentVaultFactory
      .connect(owner)
      .createVault(curator.address, "Hurdle HWM Vault", "HHWMV", 4, 2000, 250);
    const hurdleHwmVaultReceipt = await hurdleHwmVaultTx.wait();
    const hurdleHwmVaultEvent = hurdleHwmVaultReceipt?.logs.find((log) => {
      try {
        const parsed = transparentVaultFactory.interface.parseLog(log);
        return parsed?.name === "OrionVaultCreated";
      } catch {
        return false;
      }
    });
    const hurdleHwmVaultParsedEvent = transparentVaultFactory.interface.parseLog(hurdleHwmVaultEvent!);
    const hurdleHwmVaultAddress = hurdleHwmVaultParsedEvent?.args[0];
    hurdleHwmVault = (await ethers.getContractAt(
      "OrionTransparentVault",
      hurdleHwmVaultAddress,
    )) as unknown as OrionTransparentVault;

    await orionConfig.addWhitelistedCurator(await kbestTvlStrategy.getAddress());

    // Create passive vault with kbestTVL strategy (no curator intents)
    const passiveVaultTx = await transparentVaultFactory
      .connect(owner)
      .createVault(owner.address, "Passive KBest TVL Vault", "PKTV", 0, 0, 0);
    const passiveVaultReceipt = await passiveVaultTx.wait();
    const passiveVaultEvent = passiveVaultReceipt?.logs.find((log) => {
      try {
        const parsed = transparentVaultFactory.interface.parseLog(log);
        return parsed?.name === "OrionVaultCreated";
      } catch {
        return false;
      }
    });
    const passiveVaultParsedEvent = transparentVaultFactory.interface.parseLog(passiveVaultEvent!);
    const passiveVaultAddress = passiveVaultParsedEvent?.args[0];
    passiveVault = (await ethers.getContractAt(
      "OrionTransparentVault",
      passiveVaultAddress,
    )) as unknown as OrionTransparentVault;

    await passiveVault.connect(owner).updateCurator(await kbestTvlStrategy.getAddress());

    let liquidityOrchestratorBalance = await underlyingAsset.balanceOf(await liquidityOrchestrator.getAddress());
    expect(liquidityOrchestratorBalance).to.equal(0);

    // Absolute Vault: Conservative allocation with high underlying asset percentage
    const absoluteIntent = [
      {
        token: await mockAsset1.getAddress(),
        weight: 200000000,
      },
      {
        token: await mockAsset2.getAddress(),
        weight: 150000000,
      },
      {
        token: await mockAsset3.getAddress(),
        weight: 100000000,
      },
      { token: await underlyingAsset.getAddress(), weight: 550000000 },
    ];
    await absoluteVault.connect(curator).submitIntent(absoluteIntent);

    await underlyingAsset
      .connect(user)
      .approve(
        await absoluteVault.getAddress(),
        ethers.parseUnits(ABSOLUTE_VAULT_DEPOSIT.toString(), underlyingDecimals),
      );
    await absoluteVault
      .connect(user)
      .requestDeposit(ethers.parseUnits(ABSOLUTE_VAULT_DEPOSIT.toString(), underlyingDecimals));

    // Assert that after requestDeposit, the vault token supply didn't change
    const absoluteVaultTotalSupply = await absoluteVault.totalSupply();
    expect(absoluteVaultTotalSupply).to.equal(0);

    // Assert that after requestDeposit, the user's vault token balance didn't change
    const userAbsoluteVaultBalance = await absoluteVault.balanceOf(user.address);
    expect(userAbsoluteVaultBalance).to.equal(0);

    liquidityOrchestratorBalance = await underlyingAsset.balanceOf(await liquidityOrchestrator.getAddress());
    expect(liquidityOrchestratorBalance).to.equal(
      ethers.parseUnits(ABSOLUTE_VAULT_DEPOSIT.toString(), underlyingDecimals),
    );

    // Soft Hurdle Vault: Aggressive allocation with focus on mockAsset1
    const softHurdleIntent = [
      {
        token: await mockAsset1.getAddress(),
        weight: 500000000,
      },
      {
        token: await mockAsset2.getAddress(),
        weight: 250000000,
      },
      {
        token: await mockAsset3.getAddress(),
        weight: 150000000,
      },
      { token: await underlyingAsset.getAddress(), weight: 100000000 },
    ];
    await softHurdleVault.connect(curator).submitIntent(softHurdleIntent);
    await underlyingAsset
      .connect(user)
      .approve(
        await softHurdleVault.getAddress(),
        ethers.parseUnits(SOFT_HURDLE_VAULT_DEPOSIT.toString(), underlyingDecimals),
      );
    await softHurdleVault
      .connect(user)
      .requestDeposit(ethers.parseUnits(SOFT_HURDLE_VAULT_DEPOSIT.toString(), underlyingDecimals));

    liquidityOrchestratorBalance = await underlyingAsset.balanceOf(await liquidityOrchestrator.getAddress());
    expect(liquidityOrchestratorBalance).to.equal(
      ethers.parseUnits((ABSOLUTE_VAULT_DEPOSIT + SOFT_HURDLE_VAULT_DEPOSIT).toString(), underlyingDecimals),
    );

    // Hard Hurdle Vault: Diversified allocation with equal weight on mock assets
    const hardHurdleIntent = [
      {
        token: await mockAsset1.getAddress(),
        weight: 250000000,
      },
      {
        token: await mockAsset2.getAddress(),
        weight: 250000000,
      },
      {
        token: await mockAsset3.getAddress(),
        weight: 250000000,
      },
      { token: await underlyingAsset.getAddress(), weight: 250000000 },
    ];
    await hardHurdleVault.connect(curator).submitIntent(hardHurdleIntent);
    await underlyingAsset
      .connect(user)
      .approve(
        await hardHurdleVault.getAddress(),
        ethers.parseUnits(HARD_HURDLE_VAULT_DEPOSIT.toString(), underlyingDecimals),
      );
    await hardHurdleVault
      .connect(user)
      .requestDeposit(ethers.parseUnits(HARD_HURDLE_VAULT_DEPOSIT.toString(), underlyingDecimals));

    liquidityOrchestratorBalance = await underlyingAsset.balanceOf(await liquidityOrchestrator.getAddress());
    expect(liquidityOrchestratorBalance).to.equal(
      ethers.parseUnits(
        (ABSOLUTE_VAULT_DEPOSIT + SOFT_HURDLE_VAULT_DEPOSIT + HARD_HURDLE_VAULT_DEPOSIT).toString(),
        underlyingDecimals,
      ),
    );

    // High Water Mark Vault: Balanced allocation
    const highWaterMarkIntent = [
      {
        token: await mockAsset1.getAddress(),
        weight: 300000000,
      },
      {
        token: await mockAsset2.getAddress(),
        weight: 300000000,
      },
      {
        token: await mockAsset3.getAddress(),
        weight: 250000000,
      },
      { token: await underlyingAsset.getAddress(), weight: 150000000 },
    ];
    await highWaterMarkVault.connect(curator).submitIntent(highWaterMarkIntent);
    await underlyingAsset
      .connect(user)
      .approve(
        await highWaterMarkVault.getAddress(),
        ethers.parseUnits(HIGH_WATER_MARK_VAULT_DEPOSIT.toString(), underlyingDecimals),
      );
    await highWaterMarkVault
      .connect(user)
      .requestDeposit(ethers.parseUnits(HIGH_WATER_MARK_VAULT_DEPOSIT.toString(), underlyingDecimals));

    liquidityOrchestratorBalance = await underlyingAsset.balanceOf(await liquidityOrchestrator.getAddress());
    expect(liquidityOrchestratorBalance).to.equal(
      ethers.parseUnits(
        (
          ABSOLUTE_VAULT_DEPOSIT +
          SOFT_HURDLE_VAULT_DEPOSIT +
          HARD_HURDLE_VAULT_DEPOSIT +
          HIGH_WATER_MARK_VAULT_DEPOSIT
        ).toString(),
        underlyingDecimals,
      ),
    );

    // Hurdle HWM Vault: Moderate allocation with focus on mockAsset2 and mockAsset3
    const hurdleHwmIntent = [
      {
        token: await mockAsset1.getAddress(),
        weight: 150000000,
      },
      {
        token: await mockAsset2.getAddress(),
        weight: 350000000,
      },
      {
        token: await mockAsset3.getAddress(),
        weight: 350000000,
      },
      { token: await underlyingAsset.getAddress(), weight: 150000000 },
    ];
    await hurdleHwmVault.connect(curator).submitIntent(hurdleHwmIntent);
    await underlyingAsset
      .connect(user)
      .approve(
        await hurdleHwmVault.getAddress(),
        ethers.parseUnits(HURDLE_HWM_VAULT_DEPOSIT.toString(), underlyingDecimals),
      );
    await hurdleHwmVault
      .connect(user)
      .requestDeposit(ethers.parseUnits(HURDLE_HWM_VAULT_DEPOSIT.toString(), underlyingDecimals));

    await underlyingAsset
      .connect(user)
      .approve(
        await passiveVault.getAddress(),
        ethers.parseUnits(PASSIVE_VAULT_DEPOSIT.toString(), underlyingDecimals),
      );
    await passiveVault
      .connect(user)
      .requestDeposit(ethers.parseUnits(PASSIVE_VAULT_DEPOSIT.toString(), underlyingDecimals));

    liquidityOrchestratorBalance = await underlyingAsset.balanceOf(await liquidityOrchestrator.getAddress());
    expect(liquidityOrchestratorBalance).to.equal(
      ethers.parseUnits(
        (
          ABSOLUTE_VAULT_DEPOSIT +
          SOFT_HURDLE_VAULT_DEPOSIT +
          HARD_HURDLE_VAULT_DEPOSIT +
          HIGH_WATER_MARK_VAULT_DEPOSIT +
          HURDLE_HWM_VAULT_DEPOSIT +
          PASSIVE_VAULT_DEPOSIT
        ).toString(),
        underlyingDecimals,
      ),
    );
  });

  describe("Idle-only functionality", function () {
    it("should revert when system is not idle", async function () {
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(0); // Idle
      expect(await liquidityOrchestrator.currentPhase()).to.equal(0); // Idle
      void expect(await orionConfig.isSystemIdle()).to.be.true;
      await expect(orionConfig.connect(user).removeOrionVault(await hurdleHwmVault.getAddress())).not.to.be.reverted;
      await expect(orionConfig.connect(user).removeWhitelistedAsset(await mockAsset1.getAddress())).not.to.be.reverted;

      const epochDuration = await internalStatesOrchestrator.epochDuration();
      await time.increase(epochDuration + 1n);

      const [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(1); // Not idle anymore

      void expect(await orionConfig.isSystemIdle()).to.be.false;

      const vaultAddress = await hurdleHwmVault.getAddress();
      await expect(orionConfig.connect(user).removeOrionVault(vaultAddress)).to.be.revertedWithCustomError(
        orionConfig,
        "SystemNotIdle",
      );

      await expect(orionConfig.setProtocolRiskFreeRate(1000)).to.be.revertedWithCustomError(
        orionConfig,
        "SystemNotIdle",
      );

      await expect(
        orionConfig.addWhitelistedAsset(
          await mockAsset1.getAddress(),
          await orionPriceAdapter.getAddress(),
          await orionExecutionAdapter.getAddress(),
        ),
      ).to.be.revertedWithCustomError(orionConfig, "SystemNotIdle");

      await expect(
        orionConfig.connect(user).removeWhitelistedAsset(await mockAsset1.getAddress()),
      ).to.be.revertedWithCustomError(orionConfig, "SystemNotIdle");

      await expect(
        orionConfig.connect(user).removeOrionVault(await hurdleHwmVault.getAddress()),
      ).to.be.revertedWithCustomError(orionConfig, "SystemNotIdle");

      // Test InternalStatesOrchestrator functions
      await expect(internalStatesOrchestrator.updateEpochDuration(3600)).to.be.revertedWithCustomError(
        internalStatesOrchestrator,
        "SystemNotIdle",
      );

      await expect(internalStatesOrchestrator.updateMinibatchSize(5)).to.be.revertedWithCustomError(
        internalStatesOrchestrator,
        "SystemNotIdle",
      );

      await expect(internalStatesOrchestrator.updateProtocolFees(50, 1000)).to.be.revertedWithCustomError(
        internalStatesOrchestrator,
        "SystemNotIdle",
      );

      // Test LiquidityOrchestrator functions
      await expect(liquidityOrchestrator.updateExecutionMinibatchSize(5)).to.be.revertedWithCustomError(
        liquidityOrchestrator,
        "SystemNotIdle",
      );

      await expect(liquidityOrchestrator.updateAutomationRegistry(user.address)).to.be.revertedWithCustomError(
        liquidityOrchestrator,
        "SystemNotIdle",
      );

      await expect(liquidityOrchestrator.setTargetBufferRatio(100)).to.be.revertedWithCustomError(
        liquidityOrchestrator,
        "SystemNotIdle",
      );

      // Test vault functions
      const depositAmount = ethers.parseUnits("100", underlyingDecimals);
      await expect(hurdleHwmVault.connect(user).requestDeposit(depositAmount)).to.be.revertedWithCustomError(
        hurdleHwmVault,
        "SystemNotIdle",
      );

      await expect(hurdleHwmVault.connect(user).cancelDepositRequest(depositAmount)).to.be.revertedWithCustomError(
        hurdleHwmVault,
        "SystemNotIdle",
      );

      const redeemAmount = ethers.parseUnits("50", 18);
      await expect(hurdleHwmVault.connect(user).requestRedeem(redeemAmount)).to.be.revertedWithCustomError(
        hurdleHwmVault,
        "SystemNotIdle",
      );

      await expect(hurdleHwmVault.connect(user).cancelRedeemRequest(redeemAmount)).to.be.revertedWithCustomError(
        hurdleHwmVault,
        "SystemNotIdle",
      );

      await expect(hurdleHwmVault.connect(owner).updateFeeModel(0, 1000, 200)).to.be.revertedWithCustomError(
        hurdleHwmVault,
        "SystemNotIdle",
      );

      // Test factory function
      await expect(
        transparentVaultFactory.createVault(curator.address, "Test Transparent Vault", "TTV", 0, 0, 0),
      ).to.be.revertedWithCustomError(transparentVaultFactory, "SystemNotIdle");
    });
  });

  describe("performUpkeep", function () {
    it("should not update buffer after beneficial slippage epoch and no LP interactions", async function () {
      // Fast forward time to trigger upkeep
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(0); // Idle
      expect(await liquidityOrchestrator.currentPhase()).to.equal(0); // Idle
      void expect(await orionConfig.isSystemIdle()).to.be.true;

      const epochDuration = await internalStatesOrchestrator.epochDuration();
      await time.increase(epochDuration + 1n);

      let [_liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");
      void expect(_liquidityUpkeepNeeded).to.be.false;

      let [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      void expect(_upkeepNeeded).to.be.true;
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(1); // PreprocessingTransparentVaults

      const transparentVaultsEpoch = await internalStatesOrchestrator.getTransparentVaultsEpoch();
      expect(transparentVaultsEpoch.length).to.equal(6);

      // Process all vaults in preprocessing phase - continue until we reach buffering phase
      while ((await internalStatesOrchestrator.currentPhase()) === 1n) {
        [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      }

      expect(await internalStatesOrchestrator.currentPhase()).to.equal(2); // Buffering

      const bufferAmountBefore = await internalStatesOrchestrator.bufferAmount();
      console.log(`Buffer Amount Before: ${bufferAmountBefore.toString()}`);
      expect(bufferAmountBefore).to.equal(0);

      [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(3); // PostprocessingTransparentVaults

      // Process all vaults in postprocessing phase - continue until we reach building orders phase
      while ((await internalStatesOrchestrator.currentPhase()) === 3n) {
        [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      }
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(4); // BuildingOrders

      [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(0); // Back to Idle
      expect(await internalStatesOrchestrator.epochCounter()).to.equal(1); // Epoch incremented

      // Trigger a price mismatch between measured and execution in a way that benefits the vaults, leading to buffer amount increase.
      const lossAmount1 = ethers.parseUnits("500", underlyingDecimals);
      await underlyingAsset.connect(user).approve(await mockAsset1.getAddress(), lossAmount1);
      await mockAsset1.connect(user).simulateLosses(lossAmount1, user.address);

      const lossAmount2 = ethers.parseUnits("530", underlyingDecimals);
      await underlyingAsset.connect(user).approve(await mockAsset2.getAddress(), lossAmount2);
      await mockAsset2.connect(user).simulateLosses(lossAmount2, user.address);

      const lossAmount3 = ethers.parseUnits("50", underlyingDecimals);
      await underlyingAsset.connect(user).approve(await mockAsset3.getAddress(), lossAmount3);
      await mockAsset3.connect(user).simulateLosses(lossAmount3, user.address);

      // Now check if liquidity orchestrator needs to be triggered
      expect(await liquidityOrchestrator.currentPhase()).to.equal(0); // Idle

      while ((await liquidityOrchestrator.currentPhase()) !== 3n) {
        const [_liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");
        void expect(_liquidityUpkeepNeeded).to.be.true;
        await liquidityOrchestrator.connect(automationRegistry).performUpkeep(liquidityPerformData);
      }

      expect(await liquidityOrchestrator.deltaBufferAmount()).to.be.gt(0);

      const bufferAmountAfterRebalancing = await internalStatesOrchestrator.bufferAmount();

      console.log("Buffer Amount After Rebalancing:", bufferAmountAfterRebalancing.toString());
      expect(bufferAmountAfterRebalancing).to.be.gt(bufferAmountBefore);

      while ((await liquidityOrchestrator.currentPhase()) === 3n) {
        [_liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");
        void expect(_liquidityUpkeepNeeded).to.be.true;
        await liquidityOrchestrator.connect(automationRegistry).performUpkeep(liquidityPerformData);
      }

      expect(await liquidityOrchestrator.currentPhase()).to.equal(0); // Idle

      const userBalanceOfAbsoluteVault = await absoluteVault.balanceOf(user.address);
      expect(userBalanceOfAbsoluteVault).to.equal(
        ethers.parseUnits(ABSOLUTE_VAULT_DEPOSIT.toString(), await absoluteVault.decimals()),
      );

      const userBalanceOfSoftHurdleVault = await softHurdleVault.balanceOf(user.address);
      expect(userBalanceOfSoftHurdleVault).to.equal(
        ethers.parseUnits(SOFT_HURDLE_VAULT_DEPOSIT.toString(), await softHurdleVault.decimals()),
      );

      const userBalanceOfHardHurdleVault = await hardHurdleVault.balanceOf(user.address);
      expect(userBalanceOfHardHurdleVault).to.equal(
        ethers.parseUnits(HARD_HURDLE_VAULT_DEPOSIT.toString(), await hardHurdleVault.decimals()),
      );

      const userBalanceOfHighWaterMarkVault = await highWaterMarkVault.balanceOf(user.address);
      expect(userBalanceOfHighWaterMarkVault).to.equal(
        ethers.parseUnits(HIGH_WATER_MARK_VAULT_DEPOSIT.toString(), await highWaterMarkVault.decimals()),
      );

      const userBalanceOfHurdleHwmVault = await hurdleHwmVault.balanceOf(user.address);
      expect(userBalanceOfHurdleHwmVault).to.equal(
        ethers.parseUnits(HURDLE_HWM_VAULT_DEPOSIT.toString(), await hurdleHwmVault.decimals()),
      );

      // Fast forward time to trigger upkeep
      await time.increase(epochDuration + 1n);

      [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");

      while ((await internalStatesOrchestrator.currentPhase()) !== 2n) {
        [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      }

      expect(await internalStatesOrchestrator.currentPhase()).to.equal(2); // Buffering

      const bufferAmountEpoch21 = await internalStatesOrchestrator.bufferAmount();

      [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);

      const bufferAmountEpoch22 = await internalStatesOrchestrator.bufferAmount();
      expect(bufferAmountEpoch22).to.be.equal(bufferAmountEpoch21);
    });

    it("should not trigger upkeep when system is idle and time hasn't passed", async function () {
      // Don't fast forward time, so system should be idle because time hasn't passed
      const [upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      void expect(upkeepNeeded).to.be.false;
      void expect(performData).to.equal("0x");
    });

    it("should not trigger upkeep when not enough time has passed", async function () {
      // Fast forward less than epoch duration
      const epochDuration = await internalStatesOrchestrator.epochDuration();
      await time.increase(epochDuration / 2n);

      const [upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");

      void expect(upkeepNeeded).to.be.false;
      void expect(performData).to.equal("0x");
    });

    it("should allow owner to call performUpkeep", async function () {
      // Fast forward time to trigger upkeep
      const epochDuration = await internalStatesOrchestrator.epochDuration();
      await time.increase(epochDuration + 1n);

      const [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");

      // Should succeed when called by owner
      await expect(internalStatesOrchestrator.connect(owner).performUpkeep(performData)).to.not.be.reverted;
      await expect(internalStatesOrchestrator.connect(curator).performUpkeep(performData)).to.be.reverted;
    });

    it("should allow automation registry to call performUpkeep", async function () {
      // Fast forward time to trigger upkeep
      const epochDuration = await internalStatesOrchestrator.epochDuration();
      await time.increase(epochDuration + 1n);

      const [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");

      // Should succeed when called by automation registry
      await expect(internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData)).to.not.be
        .reverted;
    });

    it("should not allow unauthorized addresses to call performUpkeep", async function () {
      // Fast forward time to trigger upkeep
      const epochDuration = await internalStatesOrchestrator.epochDuration();
      await time.increase(epochDuration + 1n);

      const [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");

      // Should fail when called by non-authorized address (user)
      await expect(internalStatesOrchestrator.connect(user).performUpkeep(performData)).to.be.revertedWithCustomError(
        internalStatesOrchestrator,
        "NotAuthorized",
      );
    });

    it("should not trigger liquidity orchestrator when epoch counter hasn't changed", async function () {
      // Initially, liquidity orchestrator should not need upkeep
      let [liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");
      void expect(liquidityUpkeepNeeded).to.be.false;
      expect(liquidityPerformData).to.equal("0x");

      // Now liquidity orchestrator should not need upkeep
      [liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");
      void expect(liquidityUpkeepNeeded).to.be.false;
      expect(liquidityPerformData).to.equal("0x");
    });

    it("should allow owner to call liquidity orchestrator performUpkeep", async function () {
      // Get valid performData for liquidity orchestrator
      const [liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");

      // Should succeed when called by owner (only if upkeep is needed)
      if (liquidityUpkeepNeeded) {
        await expect(liquidityOrchestrator.connect(owner).performUpkeep(liquidityPerformData)).to.not.be.reverted;
      }
    });

    it("should allow automation registry to call liquidity orchestrator performUpkeep", async function () {
      // Get valid performData for liquidity orchestrator
      const [liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");

      // Should succeed when called by automation registry (only if upkeep is needed)
      if (liquidityUpkeepNeeded) {
        await expect(liquidityOrchestrator.connect(automationRegistry).performUpkeep(liquidityPerformData)).to.not.be
          .reverted;
      }
    });

    it("should not allow unauthorized addresses to call liquidity orchestrator performUpkeep", async function () {
      // Get valid performData for liquidity orchestrator
      const [_liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");

      // Should fail when called by non-authorized address (user)
      await expect(
        liquidityOrchestrator.connect(user).performUpkeep(liquidityPerformData),
      ).to.be.revertedWithCustomError(liquidityOrchestrator, "NotAuthorized");
    });

    it("should handle target buffer ratio calculations safely with edge cases", async function () {
      // Test with typical target buffer ratio
      await liquidityOrchestrator.setTargetBufferRatio(100);

      // Verify target buffer ratio is set correctly
      expect(await liquidityOrchestrator.targetBufferRatio()).to.equal(100);
    });

    it("should test internal states orchestrator with positive deltaAmount scenario", async function () {
      const epochDuration = await internalStatesOrchestrator.epochDuration();
      await time.increase(epochDuration + 1n);

      let [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(1);

      // Process all vaults in preprocessing phase - continue until we reach buffering phase
      while ((await internalStatesOrchestrator.currentPhase()) === 1n) {
        [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      }
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(2);

      [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(3);

      // Process all vaults in postprocessing phase - continue until we reach building orders phase
      while ((await internalStatesOrchestrator.currentPhase()) === 3n) {
        [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      }
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(4);

      [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(0);
      expect(await internalStatesOrchestrator.epochCounter()).to.equal(1);

      const initialBufferAmount = await internalStatesOrchestrator.bufferAmount();

      // Create price mismatch by simulating losses AFTER the oracle price call but BEFORE liquidity orchestrator execution
      // This will cause the execution price to be lower than the oracle price, leading to decreasing buffer amount.

      let [liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");
      void expect(liquidityUpkeepNeeded).to.be.true;
      await liquidityOrchestrator.connect(automationRegistry).performUpkeep(liquidityPerformData);
      expect(await liquidityOrchestrator.currentPhase()).to.equal(2); // From Idle to BuyingLeg (no selling in this scenario)

      // Simulate losses in mock assets to decrease their share prices
      const lossAmount1 = ethers.parseUnits("5", underlyingDecimals);
      await mockAsset1.connect(owner).simulateLosses(lossAmount1, owner.address);

      const lossAmount2 = ethers.parseUnits("7", underlyingDecimals);
      await mockAsset2.connect(owner).simulateLosses(lossAmount2, owner.address);

      const lossAmount3 = ethers.parseUnits("10", underlyingDecimals);
      await mockAsset3.connect(owner).simulateLosses(lossAmount3, owner.address);

      // Continue liquidity orchestrator execution phases
      while ((await liquidityOrchestrator.currentPhase()) === 2n) {
        [liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");
        void expect(liquidityUpkeepNeeded).to.be.true;
        await liquidityOrchestrator.connect(automationRegistry).performUpkeep(liquidityPerformData);
      }

      expect(await liquidityOrchestrator.currentPhase()).to.equal(3); // FulfillDepositAndRedeem

      while ((await liquidityOrchestrator.currentPhase()) === 3n) {
        [liquidityUpkeepNeeded, liquidityPerformData] = await liquidityOrchestrator.checkUpkeep("0x");
        void expect(liquidityUpkeepNeeded).to.be.true;
        await liquidityOrchestrator.connect(automationRegistry).performUpkeep(liquidityPerformData);
      }
      expect(await liquidityOrchestrator.currentPhase()).to.equal(0); // Idle

      // Check that buffer amount has changed due to market impact
      const finalBufferAmount = await internalStatesOrchestrator.bufferAmount();
      // The buffer amount should have changed due to market impact.
      expect(finalBufferAmount).to.be.gt(initialBufferAmount);

      // Start a new epoch to test the complete cycle with the updated buffer
      await time.increase(epochDuration + 1n);

      [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(1);

      // Process all vaults in preprocessing phase - continue until we reach buffering phase
      while ((await internalStatesOrchestrator.currentPhase()) === 1n) {
        [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      }
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(2);

      [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(3);

      // Process all vaults in postprocessing phase - continue until we reach building orders phase
      while ((await internalStatesOrchestrator.currentPhase()) === 3n) {
        [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      }
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(4);

      [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
      expect(await internalStatesOrchestrator.currentPhase()).to.equal(0);
      expect(await internalStatesOrchestrator.epochCounter()).to.equal(2);

      const depositAmount = ethers.parseUnits("1000", underlyingDecimals);
      const bufferAmountBeforeDeposit = await internalStatesOrchestrator.bufferAmount();

      await underlyingAsset.mint(user.address, depositAmount);
      await underlyingAsset.connect(user).approve(await liquidityOrchestrator.getAddress(), depositAmount);

      await liquidityOrchestrator.connect(user).depositLiquidity(depositAmount);

      // Check that the buffer amount increased by the deposit amount
      const bufferAmountAfterDeposit = await internalStatesOrchestrator.bufferAmount();
      expect(bufferAmountAfterDeposit).to.equal(bufferAmountBeforeDeposit + depositAmount);

      const withdrawAmount = ethers.parseUnits("500", underlyingDecimals);
      const bufferAmountBeforeWithdraw = bufferAmountAfterDeposit;

      await liquidityOrchestrator.connect(user).withdrawLiquidity(withdrawAmount);

      const bufferAmountAfterWithdraw = await internalStatesOrchestrator.bufferAmount();
      expect(bufferAmountAfterWithdraw).to.equal(bufferAmountBeforeWithdraw - withdrawAmount);
    });

    it("should revert depositLiquidity when system is not idle", async function () {
      const epochDuration = await internalStatesOrchestrator.epochDuration();

      // Ensure system is idle first
      const currentPhase = await internalStatesOrchestrator.currentPhase();
      if (currentPhase !== 0n) {
        // Wait for epoch to complete if needed
        await time.increase(epochDuration + 1n);
        let [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        while (_upkeepNeeded) {
          await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
          [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        }
      }

      // Start a new epoch to get system out of idle
      await time.increase(epochDuration + 1n);
      const [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);

      // System should now be in a non-idle phase
      const phase = await internalStatesOrchestrator.currentPhase();
      expect(phase).to.not.equal(0);

      const depositAmount = ethers.parseUnits("1000", underlyingDecimals);
      await underlyingAsset.mint(user.address, depositAmount);
      await underlyingAsset.connect(user).approve(await liquidityOrchestrator.getAddress(), depositAmount);

      // Should revert with SystemNotIdle
      await expect(liquidityOrchestrator.connect(user).depositLiquidity(depositAmount)).to.be.revertedWithCustomError(
        liquidityOrchestrator,
        "SystemNotIdle",
      );
    });

    it("should revert withdrawLiquidity when system is not idle", async function () {
      const epochDuration = await internalStatesOrchestrator.epochDuration();

      // Ensure system is idle first and has some buffer
      const currentPhase = await internalStatesOrchestrator.currentPhase();
      if (currentPhase !== 0n) {
        // Wait for epoch to complete if needed
        await time.increase(epochDuration + 1n);
        let [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        while (_upkeepNeeded) {
          await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);
          [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
        }
      }

      // Deposit some liquidity first when idle
      const depositAmount = ethers.parseUnits("1000", underlyingDecimals);
      await underlyingAsset.mint(user.address, depositAmount);
      await underlyingAsset.connect(user).approve(await liquidityOrchestrator.getAddress(), depositAmount);
      await liquidityOrchestrator.connect(user).depositLiquidity(depositAmount);

      // Start a new epoch to get system out of idle
      await time.increase(epochDuration + 1n);
      const [_upkeepNeeded, performData] = await internalStatesOrchestrator.checkUpkeep("0x");
      await internalStatesOrchestrator.connect(automationRegistry).performUpkeep(performData);

      // System should now be in a non-idle phase
      const phase = await internalStatesOrchestrator.currentPhase();
      expect(phase).to.not.equal(0);

      const withdrawAmount = ethers.parseUnits("500", underlyingDecimals);

      // Should revert with SystemNotIdle
      await expect(liquidityOrchestrator.connect(user).withdrawLiquidity(withdrawAmount)).to.be.revertedWithCustomError(
        liquidityOrchestrator,
        "SystemNotIdle",
      );
    });
  });
});
